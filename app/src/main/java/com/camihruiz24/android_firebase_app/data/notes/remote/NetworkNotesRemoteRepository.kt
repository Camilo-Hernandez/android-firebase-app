package com.camihruiz24.android_firebase_app.data.notes.remote

import android.content.Context
import android.util.Log
import com.camihruiz24.android_firebase_app.data.AuthenticationManager
import com.google.firebase.firestore.CollectionReference
import com.google.firebase.firestore.DocumentReference
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.MetadataChanges
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.dataObjects
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject

const val NOTES = "notes"

class NetworkNotesRemoteRepository @Inject constructor(
    @ApplicationContext context: Context
) {
    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()

    private val authManager: AuthenticationManager = AuthenticationManager(context)
    private var userId: String? = authManager.getCurrentUser()?.uid

    private val userNotesQuery: Query = firestore.collection(NOTES)
        .whereEqualTo("userId", userId).orderBy("title")

    // Forma 1
    fun getAllNotes(): Flow<List<NetworkNote>> = userNotesQuery.dataObjects(MetadataChanges.INCLUDE)


    // Forma 2
    /*
    fun getAllNotes(): Flow<List<Note>> {
        return callbackFlow {
            val registration: ListenerRegistration = userNotesQuery.addSnapshotListener { snapshot: QuerySnapshot?, _ ->
                snapshot?.let { querySnapshot ->
                    val notes = querySnapshot.toObjects<Note>()
                    // Forma larga
                    /*
                    val notes = mutableListOf<Note>()
                    // Iterar los documentos del query snapshot
                    for (document in querySnapshot.documents) {
                        val note = document.toObject(Note::class.java)
                        note?.id = document.id
                        note?.let {
                            notes.add(it)
                        }
                    }*/
                    // Se envía la lista de notas a través del canal callbackFlow
                    trySend(notes).isSuccess
                }
            }
            // Se elimina el listener para evitar fugas de memoria
            awaitClose { registration.remove() }
        }
    }
    */

    suspend fun addNote(networkNote: NetworkNote): String {
        with<CollectionReference, Unit>(firestore.collection(NOTES)) {
            // Add the note to the Firestore DB and obtain the autogenerated ID
            val noteId: String = add(networkNote)
                .run {
                    await()
                    result.id
                }

            document(noteId)
                .set(networkNote.copy(id = noteId, userId = userId.toString()))
                .await()

            return noteId
        }
    }

    suspend fun updateNote(networkNote: NetworkNote) {
        Log.d("Nota actual", networkNote.toString())
        val noteRef: DocumentReference = firestore.collection(NOTES).document(networkNote.id)
        noteRef.set(networkNote).await()
    }

    suspend fun deleteNote(noteId: String) {
        val noteRef: DocumentReference = firestore.collection(NOTES).document(noteId)
        noteRef.delete().await()
    }

}